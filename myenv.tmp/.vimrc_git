"clear existing commands
autocmd!
syntax on


set nocompatible
let mapleader = ","
imap jj <Esc> " Professor VIM says '87% of users prefer jj over esc', jj abrams disagrees

" Tabs ************************************************************************

function! TS_tabs()
  " Using 4 column tabs
  set softtabstop=4
  set shiftwidth=4
  set tabstop=4
  set noexpandtab
endfunction

function! TS_spaces()
  set softtabstop=4
  set shiftwidth=4
  set tabstop=4
  set expandtab
endfunction

call TS_spaces()

" Cursor highlights ***********************************************************
set cursorline
"set cursorcolumn

" Misc settings ***************************************************************
set ffs=unix,dos
set nomodeline
set vb t_vb=

" Colors **********************************************************************
"set t_Co=256 " 256 colors
set background=dark 
syntax on " syntax highlighting

" Want to make sure the bad space highlighting is no overwritten.
autocmd ColorScheme * highlight ExtraWhitespace ctermbg=red guibg=red

colorscheme ir_black

" Highlight any extra white space regardless of the color scheme I am using.
highlight ExtraWhitespace ctermbg=darkgreen guibg=lightgreen
match ExtraWhitespace /\s\+$|\t/
autocmd BufWinEnter * match ExtraWhitespace /\s\+$/
autocmd InsertEnter * match ExtraWhitespace /\s\+\%#\@<!$/
autocmd InsertLeave * match ExtraWhitespace /\s\+$/
"autocmd BufWinLeave * call clearmatches()

" highlight matching brackets add ' and " ??
set matchpairs+=<:>

" Status Line *****************************************************************
set showcmd
set ruler " Show ruler
set statusline=[%R%M]%F%=%h%w\ [FORMAT=%{&ff}]\ [TYPE=%Y]\ [ASCII=\%03.3b]\ [HEX=\%02.2B]\ [POS=%04l,%04v]\ [%02p%%]\ [LEN=%L]
hi StatusLine term=reverse ctermfg=0 ctermbg=7 
set laststatus=2
set showtabline=3

" Fold Lines *****************************************************************
set foldenable
set foldmethod=indent
set foldminlines=3

" Directories *****************************************************************
" TODO: check to make sure they exist and create them if they do not.
set directory=~/.vim/swap
set backupdir=~/.vim/backup
set backup

" Spell check  *****************************************************************
set spell
set spelllang=en_us
set spellfile=~/.vim/spellfile.add
set sps=best,15

" Searching *******************************************************************
set showmatch
set hlsearch
set incsearch
" make searches case-insensitive, unless they contain upper-case letters:
set ignorecase
set smartcase

" Comment format *******************************************************************
set formatoptions+=ro
set comments=sl:#*,mb:##,elx:#
set textwidth=80

" Line Wrapping ***************************************************************
set nowrap
set linebreak  " Wrap at word

" Invisible characters *********************************************************
set listchars=trail:.,tab:>-,eol:$
set nolist
:noremap <Leader>i :set list!<CR> " Toggle invisible chars

" File type specific ***************************************************************
filetype on
filetype plugin on
syntax enable

" for C-like programming, have automatic indentation:
autocmd FileType c,cpp,slang set cindent

" for HTML, generally format text, but if a long line has been created leave it
" alone when editing:
autocmd FileType html set formatoptions+=tl

" for both CSS and HTML, use genuine tab characters for indentation, to make
" files a few bytes smaller:
autocmd FileType html,css set noexpandtab tabstop=2

" in makefiles, don't expand tabs to spaces, since actual tab characters are
" needed, and have indentation at 8 chars to be sure that all indents are tabs
" (despite the mappings later):
autocmd FileType make set noexpandtab shiftwidth=8



" TODO: move to plugin file
" 2010-05-17
" Function returns a dict with 2 keys.
" label: the actual tab label
" len: length of the label contained in the key label
function! CreateTabLabelObj(n)
    let tmp = {}
    let buflist = tabpagebuflist(a:n)
    let winnr = tabpagewinnr(a:n)
    let filename = bufname(buflist[winnr - 1])
    if filename == ""
        let filename = "[No Name]"
    else
        let filename = fnamemodify(filename, ":.")
    endif
    let tmp.label = ' ' . a:n . ' ' . filename . ' '
    let tmp.len = len(tmp.label)
    if tabpagenr() == a:n
        let tmp.label = '%#TabLineSel#' . tmp.label . '%#TabLine#'
    else
        let tmp.label = '%#TabLine#' . tmp.label
    endif
    return tmp
endfunction

function! CreateTabLine()
    if ! exists("s:anchor")
        " If we don't have a tab position to anchor to the left hand
        " corner, just set it to the first tab
        let s:anchor = 1
    endif

    let curTab = tabpagenr()
    let totTab = tabpagenr('$')

    if curTab < s:anchor
        " if the current tab is less than the anchor, set the anchor
        " to the current tab.  This will happen when we move left
        let s:anchor = curTab
    endif

    " Build our tabline from anchor to the end, but make sure we dont go
    " over the width of the screen
    let tmp = BuildTabList(s:anchor, totTab)
    
    " Now check to see if our current tab made it on the list of displayed
    " tabs, and if not, move the anchor one to the right and try again
    while curTab > (s:anchor + len(tmp) - 1)
        let s:anchor = s:anchor + 1
        let tmp = BuildTabList(s:anchor, totTab)
    endwhile

    " Add a check to see if there are more tabs than we could
    " display, and if so, put a '>' at the very far right hand side
    let s:tabline = join(tmp, '|')  
    if (s:anchor + len(tmp) - 1) < totTab
        let s:tabline = s:tabline . '%=%999\>'
    endif
    " Finally, return the list of tab labels as a string separated by |
    return s:tabline
endfunction

function! BuildTabList(start, end)
    let tmp = []
    let width = 0
    let columns = &columns
    for i in range(a:start, a:end)
        " Here we are accounting for the fact that all the tab labels
        " in the tab list will be joined together with some separator
        " (we're assuming it will be one character) and therefore that
        " separator contributes to the total width
        if (i > a:start) && (i < a:end)
            let width = width + 1
        endif
        let tabObj = CreateTabLabelObj(i)
        let width = width + tabObj.len
        if width > columns
            break
        endif
        call add(tmp, tabObj.label)
    endfor
    return tmp
endfunction

" Set the tabline to our custom function
set tabline=%!CreateTabLine()

" 2010-05-18
" Playing around with moving tabs
" tab numbers run from 1 to n
function! MoveTabLeft()
    let current = tabpagenr()
    if current == 1
        let current = tabpagenr('$') + 1
    endif
    execute "tabmove" (current-2)
endfunction

function! MoveTabRight()
    let current = tabpagenr()
    if current == tabpagenr('$')
        let current = 0
    endif
    execute "tabmove" current
endfunction

" Mappings ***************************************************************
" this toggles between past and no past mode
nnoremap <F4> :set invpaste paste?<CR>
set pastetoggle=<F4>
set showmode

" Insert New Line without going into insert mode 
map <S-Enter> O<ESC> " awesome, inserts new line without going into insert mode
map <Enter> o<ESC>
"set fo-=r " do not insert a comment leader after an enter, (no work, fix!!)

" Hard to type *****************************************************************
imap uu _
imap hh =>
imap aa @

"map <silent> <C-Left> :call MoveTabLeft()<CR>
map <silent> <A-h> :call MoveTabLeft()<CR>
"map <silent> <C-Right> :call MoveTabRight()<CR>
map <silent> <A-l> :call MoveTabRight()<CR>

map <silent> <C-h> :tabp<CR>
map <silent> <C-l> :tabn<CR>

set tabline=%!CreateTabLine()

